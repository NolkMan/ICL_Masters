\section{CSP reporting analisys}

Part of my work was to evaluate the use of reporting within websites policies.

To aid me in my task NetCraft has provided me with a list of top 1 million sites.
I have requested their main pages and stored their CSP and CSPRO headers.
Later, I have scanned all policies for inclusion of reporting sources.
\texttt{report-to} and \texttt{report-uri} allow for CSP violations to be sent to the dedicated server.
Crucially their declaration is not supported in \texttt{<meta>} html tags within the source code of sites using CSP.

\subsection{Analisys Results}

From my analisys I observed that 14\% of websites that responded with a 200 OK response code were using some form of a CSP policy.
This shows a steady increase of CSP adoption by hosts compared to other studies and reports.
Unfortunatelly, through my analisys of the policies for reporting sources, I have observed that only 4\% of all policies allow for any form of reporting.

Similarly I have checked report only headers. 
Only 1\% of websites used a CSPRO header and out of those only 50\% included reporting endpoints.
Reporting only header does not change any behaviours of browsers. 
Knowing this, 50\% of hosts using a CSPRO header have it without getting any benefits of such header.

Out of 1 million sites tested, only 2881 sites reported using both active and reporting policies at the same time.
Many of those sites were various endpoints of the biggest hosts on the internet.
Through manual analisys, polices used here can be roughly split into 3 groups.

Similar, but with small changes.
For example, \texttt{instagram.com} report only policy disallows images to be loaded from \texttt{*.whatsapp.com}, which is allowed in the enforcement policy.
This method allows for sites to function as expected by users, but all occurances of a specific media will be reported.
Using reporting only header in this way may allow for eventual removal of a dependency from the site.

There were significant number of host using encforcement mode for \texttt{frame-src} and \texttt{upgrade-insecure-requests} sources and report-only header for other uses of CSP like scripts, styles or images.
This approach allows for quick deployment of low cost directives which prevent data leaks through insecure connections and clickjacking, two big attack vectors that CSP can help prevent.
While those basic security measures are in place, developers can focus on much more advanced and harder to properly create policy that included all the other directives.

Last group, most dissapointing, had identical policies for both enforcement and report only modes.
Here I have observed this behaviour in 11\% of all servers running both headers.
This may be due to developers keeping the old report only header when moving to enforcement mode after creating a policy for their website.

\section{Automated policy maker}

With such low usage of \texttt{content-security-policy-report-only} header I decided to create an automated policy maker which would allow webhosts to increase their security.

\subsection{Ideology}

Although report only header does not limit any resources from being loaded it can still be a good tool to monitor resources being loaded and aid in quick response.
Specifically when creating a report only policy I do not need to adhere to constraints of standard enforcing policies.


When using report only header I do not need the policy to contain all the loaded resources.
As the policy is not enforced and I do not risk breaking the application I may periodically remove certain sources to check whether they are still used.
In this way I always keep an up to date list of all resources used by the website.

By using report only I also do not need to make the policy work with possible updates.
Contrarly, I would like to get informed about changes to scripts used as soon as possible.
I can accomplish this when using hashes as sources instead of standard url style allowlists.
As hashes are unique to the file, users will report to my server as soon as anything changes, allowing me to be immidiately notified about potential threats.

\subsection{Development}

The server is written in JavaScript and uses Node as runtime.
This combination was used as it gives a lot of freedom during development, privides an extensive http server implementation with built-in modules and interfaces well with other software.
The server functions as a module exposing functions allowing to start a new server, which allows for communication through events.

To function it requires an oracle, which would rate scripts and provide hashes of specific resource files.
This allows for modular design, where an oracle could be improved or developed for a specific purpose without modifying the server itself.
An oracle is included in the source code which uses a machine learning model created by ??? to rate the maliciousness of the files.
I have adapted the model for my use and created a server out of it to allow my JavaScript codebase to communicate with natively Python code.

The server additionaly uses PostgreSQL to store reports and responses from the oracle.
Data is logged in the database for safe-keeping, post-deployment analisys and debugging.
Additionally the collected reports can be reused to repeat the experiments on the same data, it also reduces the strain this project exerts on websites I am using to test my algorithm.

% talk about the terminal interface

\subsection{Testing Environment}

Throughout the development of the policy maker I was never able to deploy it on a particular host.
Although it would provide a valuable insight for the real impact of the server, such option was not available.

Instead I have opted to use mitmproxy, an interactive https proxy allowing me to intercept, read and modify traffic coming through it.
It

% From what I have gathered 15\% of websites from those use CSP policies, but only 4\% use any reporting directives.
% With report-to and report-uri not being supported in meta html tags those sites have little control over violations.
% Most used directive is frame-ancestors (47\%) which stops other websites from iframe-ing the site removing a lot of attack vectors with minimal effort.
% Very high is also upgrade-insecure-requests and default-src https: blocking all insecure connections
% script-src is also widely used (34\%) but as a third of those use some form of a wildcard which nullifies the directive.
% 
% 
% When it comes to reporting only csp, only 1\% of websites use it and 50\% of them are not reporting violations anywhere.
% Here 70\% of policies limit script sources and wildcards are nearly nonexistant.
% 
% 
% Also there were only 2800 sites that used both csp and cspro headers.
% Those are the most interesting to look at, but those are carefully crafted policies of the biggest websites.
% 
% 
% Seeing those statistics I started writing an automated policy maker for the report-only header.
% This approach allows me to be more aggressive with the policies which would otherwise break the webapp:
%  > I can use hashes instead of hosts, which allows me to immidiately receive reports when a script updates to reanalize it
%  > I can periodically remove sources from my policy to check if they are still being used, keeping an up to date resource tree
% 
% My development stack consists of:
%  > node in which I have developed my server
%  > an oracle to analize the script reports. Here I have trained a basic ml model from another paper
%  > mitm-proxy which allows me to intercept and modify responses, which simulates me controlling the hosting server
%  > puppeteer to automate the process even more
%  > postgres to makee it easier to aggregate the data and allow me to repeat the execution on the same data
% 
% When creating the server I have been focusing on 4 directives I deem are the most critical to the security of websites: 
%  > upgrade-insecure-requests (default-src https:; for reporting purposes) to check and report all insecure connections from the client. From my findings and what was expected websites generally do not use insecure protocols anymore.
%  > frame-src, websites use limited amount of frames, which could be enumerated and labeled as safe/unsafe (I have not progressed it much further as I did not want to move this project into big data and scraping)
%  > script-src-attr and script-src-elem to monitor the usage of scripts, here I have found that websites berely use attribute scripts and heavily rely on inline scripts which are hard to single out and thus reliably analize
%  > require-trusted-types-for which would be the holy grail of XSS prevention, but without modification in code it generates too many reports, none of which can be supressed with directives
% 
% Now I am testing my server on random websites within top 10,000 to measure the footprint and fine-tune the behaviour.

